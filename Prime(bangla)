                                                PRIME NUMBER BLOG
                                                -----------------
প্রাইম নাম্বার হল সেই সংখ্যা যার কেবল মাত্র ২ টা গুণ্নীয়ক আছে।কোন প্রাইম সংখ্যা n এর গুণনীয়ক হলো 1 এবং n.
অর্থাৎ কোন সংখ্যা n প্রাইম হবে যদি 2 থেকে n-1 পর্যন্ত কোন সংখ্যা দিয়ে n নিঃশেষে বিভাজ্য না হয়।
এটাকে সহজ প্রোগ্রামে ইপ্লিমেন্ট করা যায়।
ইপ্লিমেন্টেশনঃ//this program returns 1 if n is prime else 0;
//কোডঃ ০১
int prime(int n)
{
	for(int i=2;i<n;i++){
		if(n%i == 0) return 0;
	}
	return 1;
}
এই কোডের কপ্লেক্সিটি হলো O(n)
আমরা জানি যে,ইভেন সংখ্যাগুলার মধ্যে কেবল মাত্র ২ প্রাইম!
তাই আমাদের ইপ্লিমেন্টেশন ্নিন্মরুপ হতে পারে...
//কোডঃ ০২
int prime(int n)
{
if(n==1) return 0;
if(n==2) return 1;

	for(int i=3;i<n;i+=2){
		if(n%i == 0) return 0;
	}
  
	return 1;
}
কিন্তু এভাবে কোড করে আসলে তেমন কোন সুবিধা হয় না।কারণ কমপ্লেক্সিটি তো কমে না,আগের মতোই O(n) ই থাকে।
কোডকে ইফিশিয়েন্ট করার উপায় হল কপ্লেক্সিটি O(n) থেকে কমানো।একটু ভাবনা চিন্তা করতে পারলেই আমরা কমপ্লেক্সিটি O(sqrt(n)) এ নামাইয়ে ফেলতে পারি।
গাণিতিক ভাবে এটা প্রমাণ করা যায় যে,কোন সংখ্যা n যদি প্রাইম না হয় তাহলে তার মোট উৎপাদকের ঠিক অর্ধেক সংখ্যক sqrt(n) এর ছোট বা সমান । যারা হয়ত এই ব্লগ পড়বে তারা খুব সহজে কনফিউস 
হয়ে যাবে,তাই আমি এখন লগিক্যালি প্রমাণ করব যে "কোন সংখ্যা n যদি প্রাইম না হয় তাহলে তার মোট উৎপাদকের ঠিক অর্ধেক সংখ্যক sqrt(n) এর  ছোট বা সমান "।
মনে করি n = p * q ;
( i ) ধরি , p এবং q উভয়ই sqrt(n) এর চেয়ে ছোট। তাহলে p < sqrt(n)  && q <sqrt(n) ভেবে দেখুন ,তাই যদি হয় তাহলে p*q < n ;যা আমাদের শর্ত বিরধী।
(ii) অনুরুপ ভাবে প্রমান করা যায় সে  p এবং q উভয়ই কখনও sqrt(n) এর বড় হতে পারে না।
(iii)হতে পারে p =  q  = sqrt(n); অথবা হতে পারে p>sqrt(n) && q<sqrt(n)  অথবা  q>sqrt(n) && p<sqrt(n);
লজিকালি প্রমাণ হয়ে গেল যে "কোন সংখ্যা n যদি প্রাইম না হয় তাহলে তার মোট উৎপাদকের ঠিক অর্ধেক সংখ্যক sqrt(n) এর  ছোট বা সমান "।
বিষয়টা  আমরা কিভাবে কোডে ইমপ্লিমেন্ট করব????
//কোড ৩
int prime(int n)
{
	for(int i=2;i*i<=n;i++){
		if(n % i == 0) return 0;
	}
	return 1;
}
আমরা সফল ভাবে আমাদের কোডের কমপ্লেক্সিটি O(sqrt(n)) এ রূপান্তর করলাম।
আর কমপ্লেক্সিটি কমানোর দরকার নাই !!! এভাবেই আমরা কোন সংখ্যা n প্রাইম কি না যাচাই করতে পারব।
আসলেই কি দরকার নাই???? ভেবে দেখুন,কি হবে যদি আমাদের বলা হয় 1 to n পর্যন্ত সকল  সংখ্যার মধ্যে কোন গুলা প্রাইম তা প্রিন্ট কর কিংবা আমাদের বলা হলো,1 to n পর্যন্ত সকল  সংখ্যার মধ্যে  কয়টা 
সংখ্যা প্রাইম???
আমরা কোড ১/২/৩ যে কোনটা ব্যবহার করেই উত্তর দিতে পারব ! কিন্তু কমপ্লেক্সিটি অনেক বেড়ে যাবে।কোড ১ অথবা ২ ব্যবহার করলে কমপ্লেক্সিটি হবে O(n2).আর ৩ নং কোড ব্যবহার করলে কমপ্লেক্সিটি হবে 
O(n*sqrt(n))....ছোট ছোট ইনপুটের জন্য আমরা হয়ত খুব দ্রুত এন্সার বের করতে পারব ! কিন্তু কি হবে যদি n এর মান অনেক বড় হয়???
আমরা চাইলে এই প্রাইম বের করার সকল প্রোগ্রামের কমপ্লেক্সিটি  কিন্তু অনেক গুণ কমাতে পারি  সিভ অফ ইরাটোস্থেন্স ব্যবহার করে!তখন আমাদের কোডের কমপ্লেক্সিটি  হবে O(N log(logN))

সিভ এলগরিদম কি???
মনে করা যাক আমাদের বের করতে হবে n প্রাইম কি না!এটা বের করার জন্য আমরা ১ থেকে n পর্যন্ত সকল সংখ্যা লিখব।তারপর যে সকল সংখ্যা প্রাইম তাদের সকল গুণিতককে কেটে দিব।আমরা ২ থেকে শুরু 
করে যদি sqrt(n) পর্যন্ত এই কাজ করতে পারি তাহলে আমরা ১ থেকে n পর্যন্ত সকল নন - প্রাইম নাম্বার কেটে ফেলতে পারব ! 
ধরা যাক আমাদের ১ থেকে ২০ পর্যন্ত কয়টা সংখ্যা প্রাইম তা বের করা লাগবে।আমরা নিচের মত করে ১-২০ পর্যন্ত সকল সংখ্যা লিখি।
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
আমরা জানি 1 নন প্রাইম ।প্রথম প্রাইম সংখ্যা 2 .তাই প্রথমে 2 এর সকল গুণিতককে কেটে দেই।
 2  3   5   7   9   11  13  15  17  19 
এবার আমরা 3 এর সকল গুনিতক কেটে দিব(অবশ্য যাদের ১ বার কটা হয়নি তাদের!)
 2  3   5   7   11  13  17  19 
পরবর্তি সংখ্যা 4 . কিন্তু 4 তো নিজেই নন-প্রাইম...তাই আমরা 4 কে স্কিপ করতে পারি। এবার আমরা 5 এর গুনিতক কাটবো।
 2  3   5   7   11  13  17  19 
অনেক হয়েছে!!!আর না।আমরা sqrt(n)=4.47(~5) পর্যন্ত সকল নাম্বারের জন্য নন প্রাইম নাম্বার কেটে ফেলছি !!!
তাহলে আমরা বলতে পারি 1 to 20 তে প্রাইম নাম্বার আছে 8 টা।
...এটাই সিভ এলগরিদম।
ইমপ্লিমেন্টেশনঃ
int isPrime(int n)
{
	int cnt = 0; 
	bool prime[n+1];
	memset(prime,true,sizeof(prime));
	prime[0] = false;
	prime[1] = false;
	
	for(int i=2;i*i<=n;i++){
		if(prime[i]==true){
			for(int j=i*i;j<=n;j+=i){
				prime[j]=false;
			}
		}
	}
	for(int i=1;i<=n;i++)
	{
		if(prime[i] == true) ++cnt;
	}
	return cnt;
}
এই এলগরিদমের কমপ্লেক্সিটি O(N*log(logN)).
অবশেষে আমরা সফল ভাবেই কপ্লেক্সিটি কমাই ফেললাম!!!

এছাড়া আছে memory efficient sieve & segmented sieve ! সেগুলা কোডকে ফাস্ট করে,কিন্তু সেগুলা নিয়ে আমার ধারণা নাই!

শাহারিয়ার আমিন
রুয়েট,সি.এস.ই- ১৯।

